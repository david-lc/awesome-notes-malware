package com.example.malwareapp;

import android.Manifest;
import android.annotation.SuppressLint;
import android.app.ActivityManager;
import android.content.Context;
import android.content.pm.PackageManager;
import android.hardware.Sensor;
import android.hardware.SensorEvent;
import android.hardware.SensorEventListener;
import android.hardware.SensorManager;
import android.os.Debug;
import android.telephony.TelephonyManager;
import android.util.Log;
import android.widget.TextView;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.NetworkInterface;
import java.net.SocketException;
import java.util.ArrayList;
import java.util.Enumeration;

public class Utils {

    // system properties
    private static final Property[] known_props = {new Property("init.svc.qemud", null),
            new Property("init.svc.qemu-props", null), new Property("qemu.hw.mainkeys", null),
            new Property("qemu.sf.fake_camera", null), new Property("qemu.sf.lcd_density", null),
            new Property("ro.bootloader", "unknown"), new Property("ro.bootmode", "unknown"),
            new Property("ro.hardware", "goldfish"), new Property("ro.kernel.android.qemud", null),
            new Property("ro.kernel.qemu.gles", null), new Property("ro.kernel.qemu", "1"),
            new Property("ro.product.device", "generic"), new Property("ro.product.model", "sdk"),
            new Property("ro.product.name", "sdk"),
            new Property("ro.serialno", null)};
    private static final int MIN_PROPERTIES_THRESHOLD = 0x5;

    public static boolean hasQEmuProps(Context context) {
        for (Property property : known_props) {
            String property_value = Syspro.getProp(context, property.name);
            /*
             * See if we expected just a non-null
             * if the property value is not null, emulator!
             * the source code it provides has some problem,
             * I change the property_value.equals("")
             */
            if ((property.seek_value == null) && (!property_value.equals(""))) {
                System.out.println("Has Qemu Props");
                return true;
            }
            // See if we expected a value to seek
            // the expected value is there, emulator!
            if ((property.seek_value != null) && (property_value.contains(property.seek_value))) {
                System.out.println("Has Qemu Props");
                return true;
            }
        }
        return false;
    }

    // qemu pipes testing
    private static final String[] known_pipes = {"/dev/socket/qemud", "/dev/qemu_pipe"};

    public static boolean hasPipes() {
        for (String pipe : known_pipes) {
            File qemu_socket = new File(pipe);
            if (qemu_socket.exists()) {
                System.out.println("Has pipes");
                return true;
            }
        }
        return false;
    }

    //genymotion file
    private static final String[] known_geny_files = {"/dev/socket/genyd", "/dev/socket/baseband_genyd"};
    public static boolean hasGenyFiles() {
        for (String file : known_geny_files) {
            File geny_file = new File(file);
            if (geny_file.exists()) {
                return true;
            }
        }
        return false;
    }

    //eth0
    public static boolean hasEth0Interface() {
        try {
            for (Enumeration<NetworkInterface> en = NetworkInterface.getNetworkInterfaces(); en.hasMoreElements(); ) {
                NetworkInterface intf = en.nextElement();
                if (intf.getName().equals("eth0")) {
                    return true;
                }
            }
        } catch (SocketException ex) {
            Log.d("test","error!");
        }
        return false;
    }

    //Build
    public static boolean hasEmulatorBuild(Context context) {
        String BOARD = android.os.Build.BOARD; // The name of the underlying board, like "unknown".
        // This appears to occur often on real hardware... that's sad
        // String BOOTLOADER = android.os.Build.BOOTLOADER; // The system bootloader version number.
        String BRAND = android.os.Build.BRAND; // The brand (e.g., carrier) the software is customized for, if any.
        // "generic"
        String DEVICE = android.os.Build.DEVICE; // The name of the industrial design. "generic"
        String HARDWARE = android.os.Build.HARDWARE; // The name of the hardware (from the kernel command line or
        // /proc). "goldfish"
        String MODEL = android.os.Build.MODEL; // The end-user-visible name for the end product. "sdk"
        String PRODUCT = android.os.Build.PRODUCT; // The name of the overall product.
        if ((BOARD.compareTo("unknown") == 0) /* || (BOOTLOADER.compareTo("unknown") == 0) */
                || (BRAND.compareTo("generic") == 0) || (DEVICE.compareTo("generic") == 0)
                || (MODEL.compareTo("sdk") == 0) || (PRODUCT.compareTo("sdk") == 0)
                || (HARDWARE.compareTo("goldfish") == 0)) {
            System.out.println("Has emulator build");
            return true;
        }
        return false;
    }

    //Operator
    public static boolean isOperatorNameAndroid(Context paramContext) {
        String szOperatorName = ((TelephonyManager) paramContext.getSystemService(Context.TELEPHONY_SERVICE)).getNetworkOperatorName();
        return szOperatorName.equalsIgnoreCase("android");
    }

    //qemu drivers
    private static final String[] known_qemu_drivers = {"goldfish"};
    public static boolean hasQEmuDrivers() {
        for (File drivers_file : new File[]{new File("/proc/tty/drivers"), new File("/proc/cpuinfo")}) {
            if (drivers_file.exists() && drivers_file.canRead()) {
                // We don't care to read much past things since info we care about should be inside here
                byte[] data = new byte[1024];
                try {
                    InputStream is = new FileInputStream(drivers_file);
                    is.read(data);
                    is.close();
                } catch (Exception exception) {
                    exception.printStackTrace();
                }

                String driver_data = new String(data);
                for (String known_qemu_driver : Utils.known_qemu_drivers) {
                    if (driver_data.contains(known_qemu_driver)) {
                        System.out.println("Has Qemu drivers");
                        return true;
                    }
                }
            }
        }
        return false;
    }

    //qemu files
    private static final String[] known_files = {"/system/lib/libc_malloc_debug_qemu.so", "/sys/qemu_trace",
            "/system/bin/qemu-props"};
    public static boolean hasQEmuFiles() {
        for (String pipe : known_files) {
            File qemu_file = new File(pipe);
            if (qemu_file.exists()) {
                return true;
            }
        }
        return false;
    }

    //ptrace
    private static final String tracerpid = "TracerPid";
    public static boolean hasTracerPid()throws IOException {
        try (BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream("/proc/self/status")), 1000)) {
            String line;

            while ((line = reader.readLine()) != null) {
                if (line.length() > tracerpid.length()) {
                    if (line.substring(0, tracerpid.length()).equalsIgnoreCase(tracerpid)) {
                        if (Integer.decode(line.substring(tracerpid.length() + 1).trim()) > 0) {
                            System.out.println("Tracerpid detected");
                            return true;
                        }
                        break;
                    }
                }
            }

        } catch (Exception exception) {
            exception.printStackTrace();
        }
        return false;
    }

    /*TaintDroid*/
    public static boolean hasPackageNameInstalled(Context context, String packageName) {
        PackageManager packageManager = context.getPackageManager();
        // In theory, if the package installer does not throw an exception, package exists
        try {
            packageManager.getInstallerPackageName(packageName);
            System.out.println("Has package name installed");
            return true;
        } catch (IllegalArgumentException exception) {
            return false;
        }
    }
    public static boolean hasAppAnalysisPackage(Context context) {
        if(Utils.hasPackageNameInstalled(context, "org.appanalysis")){
            System.out.println("Has app analysis package");
            return true;
        }else{
            return false;
        }
    }
    public static boolean hasTaintClass() {
        try {
            Class.forName("dalvik.system.Taint");
            System.out.println("Has Taint class");
            return true;
        }
        catch (ClassNotFoundException exception) {
            return false;
        }
    }

    //sensor
    private static float oldsensor;
    private static float sensor_count;
    public static boolean detectsensor(final Context context){
        try {
            final SensorManager smanger = (SensorManager) context.getSystemService(Context.SENSOR_SERVICE);
            final Sensor sensor = smanger.getDefaultSensor(Sensor.TYPE_ORIENTATION);
            SensorEventListener sensorEvent = new SensorEventListener() {
                @Override
                public void onSensorChanged(SensorEvent event) {
                    sensor_count++;
                    if((sensor_count == 2) && (event.values[0] == oldsensor)  ){
                        System.out.println("The sensor has constant value: "+ Float.toString(event.values[0]));
                    }
                    oldsensor = event.values[0];
                }

                @Override
                public void onAccuracyChanged(Sensor sensor, int accuracy) {
                }
            };
            smanger.registerListener(sensorEvent, sensor, SensorManager.SENSOR_DELAY_UI);
            return false;
        }catch (Exception e){
            System.out.println("Sensor no detected");
            return true;
        }
    }
}
